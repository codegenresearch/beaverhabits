import datetime\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List\n\nfrom beaverhabits.storage.storage import CheckedRecord, Habit, HabitList\nfrom beaverhabits.utils import generate_short_hash\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nDAY_MASK = "%Y-%m-%d"\n\n@dataclass(init=False)\nclass DictStorage:\n    data: dict = field(default_factory=dict, metadata={"exclude": True})\n\n@dataclass\nclass DictRecord(CheckedRecord, DictStorage):\n    \"""\n    Represents a record of a habit check.\n    \"""\n    @property\n    def day(self) -> datetime.date:\n        try:\n            return datetime.datetime.strptime(self.data["day"], DAY_MASK).date()\n        except KeyError as e:\n            logging.error(f"Missing key in data: {e}")\n            raise\n        except ValueError as e:\n            logging.error(f"Incorrect date format: {e}")\n            raise\n\n    @property\n    def done(self) -> bool:\n        return self.data.get("done", False)\n\n    @done.setter\n    def done(self, value: bool) -> None:\n        self.data["done"] = value\n\n@dataclass\nclass DictHabit(Habit[DictRecord], DictStorage):\n    \"""\n    Represents a habit with a list of records.\n    \"""\n    @property\n    def id(self) -> str:\n        if "id" not in self.data:\n            self.data["id"] = generate_short_hash(self.name)\n        return self.data["id"]\n\n    @property\n    def name(self) -> str:\n        return self.data.get("name", "")\n\n    @name.setter\n    def name(self, value: str) -> None:\n        self.data["name"] = value\n\n    @property\n    def star(self) -> bool:\n        return self.data.get("star", False)\n\n    @star.setter\n    def star(self, value: bool) -> None:\n        self.data["star"] = value\n\n    @property\n    def records(self) -> List[DictRecord]:\n        return [DictRecord(d) for d in self.data.get("records", [])]\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DictHabit):\n            return NotImplemented\n        return self.id == other.id\n\n    def __hash__(self) -> int:\n        return hash(self.id)\n\n    async def tick(self, day: datetime.date, done: bool) -> None:\n        record = next((r for r in self.records if r.day == day), None)\n        if record:\n            record.done = done\n        else:\n            new_record = {"day": day.strftime(DAY_MASK), "done": done}\n            self.data.setdefault("records", []).append(new_record)\n\n    async def merge(self, other: 'DictHabit') -> None:\n        if self.id != other.id:\n            logging.warning(f"Attempt to merge habits with different IDs: {self.id} and {other.id}")\n            return\n        for record in other.records:\n            if not any(r.day == record.day for r in self.records):\n                self.data.setdefault("records", []).append(record.data)\n\n@dataclass\nclass DictHabitList(HabitList[DictHabit], DictStorage):\n    \"""\n    Represents a list of habits.\n    \"""\n    @property\n    def habits(self) -> List[DictHabit]:\n        return sorted((DictHabit(d) for d in self.data.get("habits", [])), key=lambda x: x.star, reverse=True)\n\n    async def get_habit_by(self, habit_id: str) -> Optional[DictHabit]:\n        return next((habit for habit in self.habits if habit.id == habit_id), None)\n\n    async def add(self, name: str) -> None:\n        new_habit = {"name": name, "records": [], "id": generate_short_hash(name)}\n        self.data.setdefault("habits", []).append(new_habit)\n\n    async def remove(self, item: DictHabit) -> None:\n        self.data["habits"] = [h.data for h in self.habits if h.id != item.id]\n\n    async def merge(self, other: 'DictHabitList') -> None:\n        for habit in other.habits:\n            existing_habit = next((h for h in self.habits if h.id == habit.id), None)\n            if existing_habit:\n                await existing_habit.merge(habit)\n            else:\n                self.data.setdefault("habits", []).append(habit.data)\n