import datetime\nfrom dataclasses import dataclass, field\nfrom typing import Optional, List\n\nfrom beaverhabits.storage.storage import CheckedRecord, Habit, HabitList\nfrom beaverhabits.utils import generate_short_hash\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nDAY_MASK = "%Y-%m-%d"\n\n@dataclass(init=False)\nclass DictStorage:\n    data: dict = field(default_factory=dict, metadata={"exclude": True})\n\n@dataclass\nclass DictRecord(CheckedRecord, DictStorage):\n    """\n    Represents a record of a habit check.\n    """\n    @property\n    def day(self) -> datetime.date:\n        return datetime.datetime.strptime(self.data["day"], DAY_MASK).date()\n\n    @property\n    def done(self) -> bool:\n        return self.data["done"]\n\n    @done.setter\n    def done(self, value: bool) -> None:\n        self.data["done"] = value\n\n@dataclass\nclass DictHabit(Habit[DictRecord], DictStorage):\n    """\n    Represents a habit with a list of records.\n    """\n    @property\n    def id(self) -> str:\n        if "id" not in self.data:\n            self.data["id"] = generate_short_hash(self.name)\n        return self.data["id"]\n\n    @id.setter\n    def id(self, value: str) -> None:\n        self.data["id"] = value\n\n    @property\n    def name(self) -> str:\n        return self.data["name"]\n\n    @name.setter\n    def name(self, value: str) -> None:\n        self.data["name"] = value\n\n    @property\n    def star(self) -> bool:\n        return self.data.get("star", False)\n\n    @star.setter\n    def star(self, value: bool) -> None:\n        self.data["star"] = value\n\n    @property\n    def records(self) -> list[DictRecord]:\n        return [DictRecord(d) for d in self.data.get("records", [])]\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DictHabit):\n            return NotImplemented\n        return self.id == other.id\n\n    def __hash__(self) -> int:\n        return hash(self.id)\n\n    async def tick(self, day: datetime.date, done: bool) -> None:\n        record = next((r for r in self.records if r.day == day), None)\n        if record:\n            record.done = done\n        else:\n            self.data.setdefault("records", []).append({"day": day.strftime(DAY_MASK), "done": done})\n\n    async def merge(self, other: 'DictHabit') -> 'DictHabit':\n        if self.id != other.id:\n            logging.warning(f"Attempt to merge habits with different IDs: {self.id} and {other.id}")\n            return self\n        new_records = self.data.get("records", []).copy()\n        for record in other.records:\n            if not any(r.day == record.day for r in self.records):\n                new_records.append(record.data)\n        return DictHabit({"id": self.id, "name": self.name, "star": self.star, "records": new_records})\n\n@dataclass\nclass DictHabitList(HabitList[DictHabit], DictStorage):\n    """\n    Represents a list of habits.\n    Example data structure:\n    {\n        "habits": [\n            {\n                "id": "unique_id_1",\n                "name": "Habit 1",\n                "star": True,\n                "records": [\n                    {\n                        "day": "2023-10-01",\n                        "done": True\n                    }\n                ]\n            }\n        ]\n    }\n    """\n    @property\n    def habits(self) -> list[DictHabit]:\n        return sorted((DictHabit(d) for d in self.data.get("habits", [])), key=lambda x: x.star, reverse=True)\n\n    async def get_habit_by(self, habit_id: str) -> Optional[DictHabit]:\n        return next((habit for habit in self.habits if habit.id == habit_id), None)\n\n    async def add(self, name: str) -> None:\n        new_habit = {"name": name, "records": [], "id": generate_short_hash(name)}\n        self.data.setdefault("habits", []).append(new_habit)\n\n    async def remove(self, item: DictHabit) -> None:\n        self.data["habits"].remove(item.data)\n\n    async def merge(self, other: 'DictHabitList') -> 'DictHabitList':\n        new_habits = self.data.get("habits", []).copy()\n        for habit in other.habits:\n            existing_habit = next((h for h in self.habits if h.id == habit.id), None)\n            if existing_habit:\n                merged_habit = await existing_habit.merge(habit)\n                new_habits = [h for h in new_habits if h.id != existing_habit.id]\n                new_habits.append(merged_habit.data)\n            else:\n                new_habits.append(habit.data)\n        return DictHabitList({"habits": new_habits})\n