import datetime\nfrom typing import List, Optional, Protocol, TypeVar, Generic, Dict, Any\nfrom beaverhabits.app.db import User\nfrom beaverhabits.utils import generate_short_hash\nfrom pydantic import BaseModel\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom fastapi.templating import Jinja2Templates\nfrom starlette.middleware.cors import CORSMiddleware\nfrom typing_extensions import Annotated\nfrom fastapi import Depends, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi_dragdrop import DragDropRouter, DragDropItem\n\napp = FastAPI()\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_credentials=True,\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\napp.mount("/static", StaticFiles(directory="static"), name="static")\ntemplates = Jinja2Templates(directory="templates")\n\nR = TypeVar('R', bound='CheckedRecord')"H = TypeVar('H', bound='Habit')"L = TypeVar('L', bound='HabitList')\n\nclass CheckedRecord(BaseModel):\n    day: datetime.date\n    done: bool = False\n    habit_id: str\n    id: str = None\n    \\(    def __post_init__(self):\n        if not self.id:\n            self.id = generate_short_hash(f"{self.day}-{self.habit_id}")\\)    \\)    def __str__(self):\n        return f"{self.day} {'[x]' if self.done else '[ ]'}"\n    __repr__ = __str__\n\nclass Habit(BaseModel, Generic[R]):\n    id: str = None\n    name: str\n    star: bool = False\n    records: List[R] = []\n    \\(    def __post_init__(self):\n        if not self.id:\n            self.id = generate_short_hash(self.name)")    \\)    @property\n    def ticked_days(self) -> list[datetime.date]:\n        return [r.day for r in self.records if r.done]\n    \\)    async def tick(self, day: datetime.date, done: bool) -> None:\n        record = next((r for r in self.records if r.day == day), None)\n        if record:\n            record.done = done\n        else:\n            self.records.append(CheckedRecord(day=day, done=done, habit_id=self.id))\n    \\)    def __str__(self):\n        return self.name\n    __repr__ = __str__\n\nclass HabitList(BaseModel, Generic[H]):\n    habits: List[H] = []\n    order: List[str] = []\n    \\)    @property\n    def sorted_habits(self) -> List[H]:\n        habits = self.habits.copy()\n        if self.order:\n            habits.sort(key=lambda x: self.order.index(x.id) if x.id in self.order else float('inf'))\n        else:\n            habits.sort(key=lambda x: x.star, reverse=True)\n        return habits\n    \\)    async def add(self, name: str) -> None:\n        new_habit = Habit(name=name)\n        self.habits.append(new_habit)\n        self.order.append(new_habit.id)\n    \\)    async def remove(self, item: H) -> None:\n        self.habits = [h for h in self.habits if h.id != item.id]\n        self.order = [o for o in self.order if o != item.id]\n    \\)    async def get_habit_by(self, habit_id: str) -> Optional[H]:\n        return next((h for h in self.habits if h.id == habit_id), None)\n    \\)    async def merge(self, other: 'HabitList') -> 'HabitList':\n        result = set(self.habits).symmetric_difference(set(other.habits))\n        for self_habit in self.habits:\n            for other_habit in other.habits:\n                if self_habit == other_habit:\n                    new_habit = await self_habit.merge(other_habit)\n                    result.add(new_habit)\n        return HabitList(habits=list(result))\n    \\)    def __str__(self):\n        return f"HabitList({len(self.habits)} habits)"\n    __repr__ = __str__\n\nclass SessionStorage(Generic[L]):\n    def get_user_habit_list(self) -> Optional[L]:\n        # Implement session storage logic here\n        pass\n    \\)    def save_user_habit_list(self, habit_list: L) -> None:\n        # Implement session storage logic here\n        pass\n\nclass UserStorage(Generic[L]):\n    async def get_user_habit_list(self, user: User) -> Optional[L]:\n        # Implement user storage logic here\n        pass\n    \\)    async def save_user_habit_list(self, user: User, habit_list: L) -> None:\n        # Implement user storage logic here\n        pass\n    \\)    async def merge_user_habit_list(self, user: User, other: L) -> L:\n        # Implement user storage logic here\n        pass\n\n# Drag and Drop functionality\ndragdrop_router = DragDropRouter()\n\n@dragdrop_router.on_drop\nasync def handle_drop(item: DragDropItem, request: Request):\n    user_habit_list = await get_user_habit_list(request)\n    if not user_habit_list:\n        raise HTTPException(status_code=404, detail="User habit list not found")\n    \\)    # Update the order based on the drag and drop action\n    user_habit_list.order = [item.id for item in item.items]\n    await save_user_habit_list(request, user_habit_list)\n    return JSONResponse(content={"status": "success"})\n\napp.include_router(dragdrop_router)\n\n# Example routes\n@app.get("/", response_class=HTMLResponse)\nasync def read_root(request: Request):\n    return templates.TemplateResponse("index.html", {"request": request})\n\n@app.get("/habits", response_model=HabitList)\nasync def get_habits(request: Request):\n    user_habit_list = await get_user_habit_list(request)\n    if not user_habit_list:\n        raise HTTPException(status_code=404, detail="User habit list not found")\n    return user_habit_list\n\n@app.post("/habits", response_model=HabitList)\nasync def add_habit(request: Request, name: str):\n    user_habit_list = await get_user_habit_list(request)\n    if not user_habit_list:\n        user_habit_list = HabitList()\n    await user_habit_list.add(name)\n    await save_user_habit_list(request, user_habit_list)\n    return user_habit_list\n\n@app.delete("/habits/{habit_id}", response_model=HabitList)\nasync def remove_habit(request: Request, habit_id: str):\n    user_habit_list = await get_user_habit_list(request)\n    if not user_habit_list:\n        raise HTTPException(status_code=404, detail="User habit list not found")\n    habit = await user_habit_list.get_habit_by(habit_id)\n    if not habit:\n        raise HTTPException(status_code=404, detail="Habit not found")\n    await user_habit_list.remove(habit)\n    await save_user_habit_list(request, user_habit_list)\n    return user_habit_list\n\n# Mock implementations for session storage\nasync def get_user_habit_list(request: Request) -> Optional[HabitList]:\n    # Here you would retrieve the habit list from the session or user data\n    return request.session.get("user_habit_list")\n\nasync def save_user_habit_list(request: Request, habit_list: HabitList) -> None:\n    # Here you would save the habit list to the session or user data\n    request.session["user_habit_list"] = habit_list