import datetime\nimport json\nimport random\nimport time\nfrom typing import List\n\nfrom fastapi import HTTPException\nfrom nicegui import ui\n\nfrom beaverhabits.app.db import User\nfrom beaverhabits.storage import get_user_dict_storage, session_storage\nfrom beaverhabits.storage.dict import DAY_MASK, DictHabitList\nfrom beaverhabits.storage.storage import Habit, HabitList\nfrom beaverhabits.utils import generate_short_hash\n\nuser_storage = get_user_dict_storage()\n\ndef dummy_habit_list(days: List[datetime.date]) -> DictHabitList:\n    pick = lambda: random.randint(0, 3) == 0\n    items = [\n        {\n            "id": generate_short_hash(name),\n            "name": name,\n            "records": [\n                {"day": day.strftime(DAY_MASK), "done": pick()} for day in days\n            ],\n        }\n        for name in ("Order pizza", "Running", "Table Tennis", "Clean", "Call mom")\n    ]\n    return DictHabitList({"habits": items})\n\ndef get_session_habit_list() -> HabitList | None:\n    return session_storage.get_user_habit_list()\n\nasync def get_session_habit(habit_id: str) -> Habit:\n    habit_list = get_session_habit_list()\n    if habit_list is None:\n        raise HTTPException(status_code=404, detail="Habit list not found")\n\n    habit = await habit_list.get_habit_by(habit_id)\n    if habit is None:\n        raise HTTPException(status_code=404, detail="Habit not found")\n\n    return habit\n\ndef get_or_create_session_habit_list(days: List[datetime.date]) -> HabitList:\n    if (habit_list := get_session_habit_list()) is not None:\n        return habit_list\n\n    habit_list = dummy_habit_list(days)\n    session_storage.save_user_habit_list(habit_list)\n    return habit_list\n\nasync def get_user_habit_list(user: User) -> HabitList | None:\n    return await user_storage.get_user_habit_list(user)\n\nasync def get_user_habit(user: User, habit_id: str) -> Habit:\n    habit_list = await get_user_habit_list(user)\n    if habit_list is None:\n        raise HTTPException(status_code=404, detail="Habit list not found")\n\n    habit = await habit_list.get_habit_by(habit_id)\n    if habit is None:\n        raise HTTPException(status_code=404, detail="Habit not found")\n\n    return habit\n\nasync def get_or_create_user_habit_list(user: User, days: List[datetime.date]) -> HabitList:\n    habit_list = await get_user_habit_list(user)\n    if habit_list is not None:\n        return habit_list\n\n    habit_list = dummy_habit_list(days)\n    await user_storage.save_user_habit_list(user, habit_list)\n    return habit_list\n\nasync def export_user_habit_list(habit_list: HabitList, user_identify: str) -> None:\n    # Export habit list\n    if isinstance(habit_list, DictHabitList):\n        data = {\n            "user_email": user_identify,\n            "exported_at": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),\n            **habit_list.data,\n        }\n        binary_data = json.dumps(data).encode()\n        file_name = f"habits_{int(float(time.time()))}.json"\n        ui.download(binary_data, file_name)\n    else:\n        ui.notification("Export failed, please try again later.")\n\nclass DictHabitList(HabitList[Habit]):\n    def __init__(self, data: dict):\n        self.data = data\n\n    def get_habit_by(self, habit_id: str) -> Habit | None:\n        for habit in self.data["habits"]:\n            if habit["id"] == habit_id:\n                return DictHabit(habit)\n        return None\n\n    async def add(self, name: str) -> None:\n        new_habit = {\n            "id": generate_short_hash(name),\n            "name": name,\n            "records": [],\n        }\n        self.data["habits"].append(new_habit)\n\n    async def remove(self, item: Habit) -> None:\n        self.data["habits"] = [habit for habit in self.data["habits"] if habit["id"] != item.id]\n\n    def __str__(self) -> str:\n        return f"HabitList with {len(self.data[\"habits\"]) } habits"\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n    def merge(self, other: HabitList) -> None:\n        other_habits = {habit.id: habit for habit in other.habits}\n        for habit in self.data["habits"]:\n            if habit["id"] in other_habits:\n                other_habit = other_habits[habit["id"]]\n                habit["records"].extend([record for record in other_habit.records if record not in habit["records"]])\n            else:\n                self.data["habits"].append(habit)\n\nclass DictHabit(Habit[CheckedRecord]):\n    def __init__(self, data: dict):\n        self.data = data\n\n    @property\n    def id(self) -> str:\n        return self.data["id"]\n\n    @property\n    def name(self) -> str:\n        return self.data["name"]\n\n    @name.setter\n    def name(self, value: str) -> None:\n        self.data["name"] = value\n\n    @property\n    def star(self) -> bool:\n        return self.data.get("star", False)\n\n    @star.setter\n    def star(self, value: bool) -> None:\n        self.data["star"] = value\n\n    @property\n    def records(self) -> List[CheckedRecord]:\n        return [DictCheckedRecord(record) for record in self.data["records"]]\n\n    async def tick(self, day: datetime.date, done: bool) -> None:\n        record = next((r for r in self.records if r.day == day), None)\n        if record:\n            record.done = done\n        else:\n            self.data["records"].append({"day": day.strftime(DAY_MASK), "done": done})\n\n    def __str__(self) -> str:\n        return f"Habit: {self.name}, Starred: {self.star}, Ticked Days: {len(self.ticked_days)}"\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\nclass DictCheckedRecord(CheckedRecord):\n    def __init__(self, data: dict):\n        self.data = data\n\n    @property\n    def day(self) -> datetime.date:\n        return datetime.datetime.strptime(self.data["day"], DAY_MASK).date()\n\n    @property\n    def done(self) -> bool:\n        return self.data["done"]\n\n    @done.setter\n    def done(self, value: bool) -> None:\n        self.data["done"] = value\n\n    def __str__(self) -> str:\n        return f"{self.day} {'[x]' if self.done else '[ ]'}"\n\n    def __repr__(self) -> str:\n        return self.__str__()\n