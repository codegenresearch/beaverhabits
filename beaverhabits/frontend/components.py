import calendar\nimport datetime\nfrom dataclasses import dataclass\nfrom typing import Callable, List, Optional, Dict\nfrom nicegui import events, ui\nfrom nicegui.elements.button import Button\nfrom beaverhabits.configs import settings\nfrom beaverhabits.frontend import icons\nfrom beaverhabits.logging import logger\nfrom beaverhabits.storage.dict import DAY_MASK, MONTH_MASK\nfrom beaverhabits.storage.storage import Habit, HabitList\nfrom beaverhabits.utils import WEEK_DAYS\nfrom beaverhabits.frontend.components import HabitAddCard\nstrptime = datetime.datetime.strptime\ndef link(text: str, target: str) -> ui.link:\n    return ui.link(text, target=target).classes(\n        "dark:text-white no-underline hover:no-underline"\n    )\ndef menu_header(title: str, target: str) -> ui.link:\n    link = ui.link(title, target=target)\n    link.classes(\n        "text-semibold text-2xl dark:text-white no-underline hover:no-underline"\n    )\n    return link\ndef compat_menu(name: str, callback: Callable) -> ui.menu_item:\n    return ui.menu_item(name, callback).props("dense").classes("items-center")\ndef menu_icon_button(icon_name: str, click: Optional[Callable] = None) -> Button:\n    button_props = "flat=true unelevated=true padding=xs background=none"\n    return ui.button(icon=icon_name, color=None, on_click=click).props(button_props)\nclass HabitCheckBox(ui.checkbox):\n    def __init__(\n        self,\n        habit: Habit,\n        day: datetime.date,\n        text: str = "",\n        *,\n        value: bool = False,\n    ) -> None:\n        super().__init__(text, value=value, on_change=self._async_task)\n        self.habit = habit\n        self.day = day\n        self._update_style(value)\n    def _update_style(self, value: bool) -> None:\n        self.props(\n            f'checked-icon="{icons.DONE}" unchecked-icon="{icons.CLOSE}" keep-color'\n        )\n        if not value:\n            self.props("color=grey-8")\n        else:\n            self.props("color=currentColor")\n    async def _async_task(self, e: events.ValueChangeEventArguments) -> None:\n        self._update_style(e.value)\n        await self.habit.tick(self.day, e.value)\n        logger.info(f"Day {self.day} ticked: {e.value}")\nclass HabitNameInput(ui.input):\n    def __init__(self, habit: Habit) -> None:\n        super().__init__(value=habit.name, on_change=self._async_task)\n        self.habit = habit\n        self.validation = lambda value: "Too long" if len(value) > 18 else None\n        self.props("dense")\n    async def _async_task(self, e: events.ValueChangeEventArguments) -> None:\n        self.habit.name = e.value\n        logger.info(f"Habit Name changed to {e.value}")\nclass HabitStarCheckbox(ui.checkbox):\n    def __init__(self, habit: Habit, refresh: Callable) -> None:\n        super().__init__("", value=habit.star, on_change=self._async_task)\n        self.habit = habit\n        self.bind_value(habit, "star")\n        self.props(f'checked-icon="{icons.STAR_FULL}" unchecked-icon="{icons.STAR}"')\n        self.props("flat fab-mini keep-color color=grey-8")\n        self.refresh = refresh\n    async def _async_task(self, e: events.ValueChangeEventArguments) -> None:\n        self.habit.star = e.value\n        self.refresh()\n        logger.info(f"Habit Star changed to {e.value}")\nclass HabitDeleteButton(ui.button):\n    def __init__(self, habit: Habit, habit_list: HabitList, refresh: Callable) -> None:\n        super().__init__(on_click=self._async_task, icon=icons.DELETE)\n        self.habit = habit\n        self.habit_list = habit_list\n        self.refresh = refresh\n    async def _async_task(self) -> None:\n        await self.habit_list.remove(self.habit)\n        self.refresh()\n        logger.info(f"Deleted habit: {self.habit.name}")\nclass HabitAddButton(ui.input):\n    def __init__(self, habit_list: HabitList, refresh: Callable) -> None:\n        super().__init__("New item")\n        self.habit_list = habit_list\n        self.refresh = refresh\n        self.on("keydown.enter", self._async_task)\n        self.props("dense")\n    async def _async_task(self) -> None:\n        logger.info(f"Adding new habit: {self.value}")\n        await self.habit_list.add(self.value)\n        self.refresh()\n        self.set_value("")\n        logger.info(f"Added new habit: {self.value}")\nTODAY = "today"\nclass HabitDateInput(ui.date):\n    def __init__(\n        self,\n        today: datetime.date,\n        habit: Habit,\n        ticked_data: Dict[datetime.date, bool],\n    ) -> None:\n        self.today = today\n        self.habit = habit\n        self.ticked_data = ticked_data\n        self.init = True\n        self.default_date = today\n        super().__init__(self.ticked_days, on_change=self._async_task)\n        self.props("multiple")\n        self.props("minimal flat")\n        self.props(f"default-year-month={self.today.strftime(MONTH_MASK)}")\n        qdate_week_first_day = (settings.FIRST_DAY_OF_WEEK + 1) % 7\n        self.props(f"first-day-of-week='{qdate_week_first_day}'")\n        self.props("today-btn")\n        self.classes("shadow-none")\n        self.bind_value_from(self, "ticked_days")\n    @property\n    def ticked_days(self) -> List[str]:\n        result = [k.strftime(DAY_MASK) for k, v in self.ticked_data.items() if v]\n        result.append(TODAY)\n        return result\n    async def _async_task(self, e: events.ValueChangeEventArguments) -> None:\n        old_values = set(self.habit.ticked_days)\n        new_values = set(strptime(x, DAY_MASK).date() for x in e.value if x != TODAY)\n        for day in new_values - old_values:\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\n            self.ticked_data[day] = True\n            await self.habit.tick(day, True)\n            logger.info(f"QDate day {day} ticked: True")\n        for day in old_values - new_values:\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\n            self.ticked_data[day] = False\n            await self.habit.tick(day, False)\n            logger.info(f"QDate day {day} ticked: False")\n@dataclass\nclass CalendarHeatmap:\n    today: datetime.date\n    headers: List[str]\n    data: List[List[datetime.date]]\n    week_days: List[str]\n    @classmethod\n    def build(\n        cls,\n        today: datetime.date,\n        weeks: int,\n        firstweekday: int = calendar.MONDAY,\n    ):\n        data = cls.generate_calendar_days(today, weeks, firstweekday)\n        headers = cls.generate_calendar_headers(data[0])\n        week_day_abbr = [calendar.day_abbr[(firstweekday + i) % 7] for i in range(7)]\n        return cls(today, headers, data, week_day_abbr)\n    @staticmethod\n    def generate_calendar_headers(days: List[datetime.date]) -> List[str]:\n        if not days:\n            return []\n        result = []\n        month = year = None\n        for day in days:\n            cur_month, cur_year = day.month, day.year\n            if cur_month != month:\n                result.append(calendar.month_abbr[cur_month])\n                month = cur_month\n                continue\n            if cur_year != year:\n                result.append(str(cur_year))\n                year = cur_year\n                continue\n            result.append("")\n        return result\n    @staticmethod\n    def generate_calendar_days(\n        today: datetime.date,\n        total_weeks: int,\n        firstweekday: int = calendar.MONDAY,\n    ) -> List[List[datetime.date]]:\n        lastweekday = (firstweekday - 1) % 7\n        days_delta = (lastweekday - today.weekday()) % 7\n        last_date_of_calendar = today + datetime.timedelta(days=days_delta)\n        return [\n            [\n                last_date_of_calendar - datetime.timedelta(days=i, weeks=j)\n                for j in reversed(range(total_weeks))\n            ]\n            for i in reversed(range(WEEK_DAYS))\n        ]\nclass CalendarCheckBox(ui.checkbox):\n    def __init__(\n        self,\n        habit: Habit,\n        day: datetime.date,\n        today: datetime.date,\n        ticked_data: Dict[datetime.date, bool],\n        is_bind_data: bool = True,\n    ) -> None:\n        self.habit = habit\n        self.day = day\n        self.today = today\n        self.ticked_data = ticked_data\n        super().__init__("", value=self.ticked, on_change=self._async_task)\n        self.classes("inline-block")\n        self.props("dense")\n        unchecked_icon, checked_icon = self._icon_svg()\n        self.props(f'unchecked-icon="{unchecked_icon}"')\n        self.props(f'checked-icon="{checked_icon}"')\n        if is_bind_data:\n            self.bind_value_from(self, "ticked")\n    @property\n    def ticked(self) -> bool:\n        return self.ticked_data.get(self.day, False)\n    def _icon_svg(self) -> tuple:\n        unchecked_color, checked_color = "rgb(54,54,54)", "rgb(103,150,207)"\n        return (\n            icons.SQUARE.format(color=unchecked_color, text=self.day.day),\n            icons.SQUARE.format(color=checked_color, text=self.day.day),\n        )\n    async def _async_task(self, e: events.ValueChangeEventArguments) -> None:\n        self.ticked_data[self.day] = e.value\n        await self.habit.tick(self.day, e.value)\n        logger.info(f"Calendar Day {self.day} ticked: {e.value}")\ndef habit_heat_map(\n    habit: Habit,\n    habit_calendar: CalendarHeatmap,\n    ticked_data: Optional[Dict[datetime.date, bool]] = None,\) -> None:\n    today = habit_calendar.today\n    is_bind_data = True\n    if ticked_data is None:\n        ticked_data = {x: True for x in habit.ticked_days}\n        is_bind_data = False\n    with ui.row(wrap=False).classes("gap-0"):\n        for header in habit_calendar.headers:\n            ui.label(header).classes("text-gray-300 text-center").style("width: 20px; line-height: 18px; font-size: 9px;")\n        ui.label().style("width: 22px;")\n    for i, weekday_days in enumerate(habit_calendar.data):\n        with ui.row(wrap=False).classes("gap-0"):\n            for day in weekday_days:\n                if day <= habit_calendar.today:\n                    CalendarCheckBox(habit, day, today, ticked_data, is_bind_data)\n                else:\n                    ui.label().style("width: 20px; height: 20px;")\n            ui.label(habit_calendar.week_days[i]).classes("indent-1.5 text-gray-300").style("width: 22px; line-height: 20px; font-size: 9px;")\ndef display_habit(habit: Habit, ticked_data: Dict[datetime.date, bool], refresh: Callable) -> None:\n    with HabitAddCard():\n        HabitNameInput(habit)\n        HabitStarCheckbox(habit, refresh)\n        HabitDeleteButton(habit, habit.habit_list, refresh)\n        HabitDateInput(habit.today, habit, ticked_data)\n        habit_calendar = CalendarHeatmap.build(habit.today, 15, calendar.MONDAY)\n        habit_heat_map(habit, habit_calendar, ticked_data)\