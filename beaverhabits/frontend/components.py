import calendar\nfrom dataclasses import dataclass\nimport datetime\nfrom typing import Callable, Optional, Dict\nfrom beaverhabits.configs import settings\nfrom beaverhabits.frontend import icons\nfrom beaverhabits.logging import logger\nfrom beaverhabits.storage.dict import DAY_MASK, MONTH_MASK\nfrom beaverhabits.storage.storage import Habit, HabitList\nfrom beaverhabits.utils import WEEK_DAYS\nfrom nicegui import events, ui\nfrom nicegui.elements.button import Button\n\nstrptime = datetime.datetime.strptime\n\n\nclass DictHabit(Habit):\n    def __init__(self, name: str, star: bool = False, ticked_days: Optional[Dict[datetime.date, bool]] = None):\n        super().__init__(name, star)\n        self.ticked_days = ticked_days if ticked_days is not None else {}\n        self.status = 'active'\n\n    @property\n    def status(self) -> str:\n        return self._status\n\n    @status.setter\n    def status(self, value: str):\n        self._status = value\n\n\nclass DictHabitList(HabitList):\n    def __init__(self, habits: Optional[list[DictHabit]] = None):\n        super().__init__(habits if habits is not None else [])\n\n    def filter_by_status(self, status: str) -> list[DictHabit]:\n        return [habit for habit in self.habits if habit.status == status]\n\n\nclass HabitCheckBox(ui.checkbox):\n    def __init__(self, habit: DictHabit, day: datetime.date, text: str = ", *, value: bool = False) -> None:\n        super().__init__(text, value=value, on_change=self._async_task)\n        self.habit = habit\n        self.day = day\n        self._update_style(value)\n\n    def _update_style(self, value: bool):\n        self.props(f'checked-icon="{icons.DONE}" unchecked-icon="{icons.CLOSE}" keep-color')\n        if not value:\n            self.props("color=grey-8")\n        else:\n            self.props("color=currentColor")\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self._update_style(e.value)\n        await self.habit.tick(self.day, e.value)\n        logger.info(f"Day {self.day} ticked: {e.value}")\n\n\nclass HabitOrderCard(ui.card):\n    def __init__(self, habit: DictHabit | None = None) -> None:\n        super().__init__()\n        self.habit = habit\n        self.props("flat dense")\n        self.classes("py-0.5 w-full")\n        if habit:\n            self.props("draggable")\n            self.classes("cursor-grab")\n\n\nclass HabitNameInput(ui.input):\n    def __init__(self, habit: DictHabit) -> None:\n        super().__init__(value=habit.name)\n        self.habit = habit\n        self.validation = self._validate\n        self.props("dense hide-bottom-space")\n        self.on("blur", self._async_task)\n\n    async def _async_task(self):\n        self.habit.name = self.value\n        logger.info(f"Habit Name changed to {self.value}")\n\n    def _validate(self, value: str) -> Optional[str]:\n        if not value:\n            return "Name is required"\n        if len(value) > 18:\n            return "Too long"\n\n\nclass HabitStarCheckbox(ui.checkbox):\n    def __init__(self, habit: DictHabit, refresh: Callable) -> None:\n        super().__init__("", value=habit.star, on_change=self._async_task)\n        self.habit = habit\n        self.bind_value(habit, "star")\n        self.props(f'checked-icon="{icons.STAR_FULL}" unchecked-icon="{icons.STAR}"')\n        self.props("flat fab-mini keep-color color=grey-8")\n        self.refresh = refresh\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self.habit.star = e.value\n        self.refresh()\n        logger.info(f"Habit Star changed to {e.value}")\n\n\nclass HabitDeleteButton(ui.button):\n    def __init__(self, habit: DictHabit, habit_list: DictHabitList, refresh: Callable) -> None:\n        super().__init__(on_click=self._async_task, icon=icons.DELETE)\n        self.habit = habit\n        self.habit_list = habit_list\n        self.refresh = refresh\n        self.props("flat fab-mini color=grey")\n\n    async def _async_task(self):\n        await self.habit_list.remove(self.habit)\n        self.refresh()\n        logger.info(f"Deleted habit: {self.habit.name}")\n\n\nclass HabitAddButton(ui.input):\n    def __init__(self, habit_list: DictHabitList, refresh: Callable) -> None:\n        super().__init__("New item")\n        self.habit_list = habit_list\n        self.refresh = refresh\n        self.on("keydown.enter", self._async_task)\n        self.props("dense")\n        self.props("flat fab-mini color=grey")\n\n    async def _async_task(self):\n        logger.info(f"Adding new habit: {self.value}")\n        await self.habit_list.add(self.value)\n        self.refresh()\n        self.set_value("")\n        logger.info(f"Added new habit: {self.value}")\n\n\nclass HabitDateInput(ui.date):\n    def __init__(self, today: datetime.date, habit: DictHabit, ticked_data: dict[datetime.date, bool]) -> None:\n        self.today = today\n        self.habit = habit\n        self.ticked_data = ticked_data\n        self.init = True\n        self.default_date = today\n        super().__init__(self.ticked_days, on_change=self._async_task)\n        self.props("multiple")\n        self.props("minimal flat")\n        self.props(f"default-year-month={self.today.strftime(MONTH_MASK)}")\n        qdate_week_first_day = (settings.FIRST_DAY_OF_WEEK + 1) % 7\n        self.props(f"first-day-of-week='{qdate_week_first_day}'")\n        self.props("today-btn")\n        self.classes("shadow-none")\n        self.bind_value_from(self, "ticked_days")\n\n    @property\n    def ticked_days(self) -> list[str]:\n        result = [k.strftime(DAY_MASK) for k, v in self.ticked_data.items() if v]\n        result.append("today")\n        return result\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        old_values = set(self.habit.ticked_days)\n        new_values = set(strptime(x, DAY_MASK).date() for x in e.value if x != "today")\n        for day in new_values - old_values:\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\n            self.ticked_data[day] = True\n            await self.habit.tick(day, True)\n            logger.info(f"QDate day {day} ticked: True")\n        for day in old_values - new_values:\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\n            self.ticked_data[day] = False\n            await self.habit.tick(day, False)\n            logger.info(f"QDate day {day} ticked: False")\n\n\nclass CalendarCheckBox(ui.checkbox):\n    def __init__(self, habit: DictHabit, day: datetime.date, today: datetime.date, ticked_data: dict[datetime.date, bool], is_bind_data: bool = True) -> None:\n        self.habit = habit\n        self.day = day\n        self.today = today\n        self.ticked_data = ticked_data\n        super().__init__("", value=self.ticked, on_change=self._async_task)\n        self.classes("inline-block")\n        self.props("dense")\n        unchecked_icon, checked_icon = self._icon_svg()\n        self.props(f'unchecked-icon="{unchecked_icon}"')\n        self.props(f'checked-icon="{checked_icon}"')\n        if is_bind_data:\n            self.bind_value_from(self, "ticked")\n\n    @property\n    def ticked(self) -> bool:\n        return self.ticked_data.get(self.day, False)\n\n    def _icon_svg(self) -> tuple[str, str]:\n        unchecked_color, checked_color = "rgb(54,54,54)", "rgb(103,150,207)"\n        return (\n            icons.SQUARE.format(color=unchecked_color, text=self.day.day),\n            icons.SQUARE.format(color=checked_color, text=self.day.day),\n        )\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self.ticked_data[self.day] = e.value\n        await self.habit.tick(self.day, e.value)\n        logger.info(f"Calendar Day {self.day} ticked: {e.value}")\n