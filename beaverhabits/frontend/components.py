import calendar\nfrom dataclasses import dataclass\nimport datetime\nfrom typing import Callable, Optional, Dict\nfrom beaverhabits.configs import settings\nfrom beaverhabits.frontend import icons\nfrom beaverhabits.logging import logger\nfrom beaverhabits.storage.dict import DAY_MASK, MONTH_MASK\nfrom beaverhabits.storage.storage import Habit, HabitList\nfrom beaverhabits.utils import WEEK_DAYS\nfrom nicegui import events, ui\nfrom nicegui.elements.button import Button\n\nstrptime = datetime.datetime.strptime\n\nclass DictHabit(Habit):\n    def __init__(self, name: str, star: bool = False, ticked_days: Optional[Dict[datetime.date, bool]] = None):\n        super().__init__(name, star)\n        self.ticked_days = ticked_days if ticked_days is not None else {}\n        self.status = 'active'\n\nclass DictHabitList(HabitList):\n    def __init__(self, habits: Optional[list[DictHabit]] = None):\n        super().__init__(habits if habits is not None else [])\n    \\    def filter_by_status(self, status: str):\\        return [habit for habit in self.habits if habit.status == status]\n\nclass HabitCheckBox(ui.checkbox):\\    def __init__(self, habit: DictHabit, day: datetime.date, text: str = "", *, value: bool = False) -> None:\\        super().__init__(text, value=value, on_change=self._async_task)\\        self.habit = habit\\        self.day = day\\        self._update_style(value)\\    \\    def _update_style(self, value: bool):\\        self.props(f'checked-icon="{icons.DONE}" unchecked-icon="{icons.CLOSE}" keep-color')\\        if not value:\\            self.props("color=grey-8")\\        else:\\            self.props("color=currentColor")\\    \\    async def _async_task(self, e: events.ValueChangeEventArguments):\\        self._update_style(e.value)\\        await self.habit.tick(self.day, e.value)\\        logger.info(f"Day {self.day} ticked: {e.value}")\n\nclass HabitOrderCard(ui.card):\\    def __init__(self, habit: DictHabit | None = None) -> None:\\        super().__init__()\\        self.habit = habit\\        self.props("flat dense")\\        self.classes("py-0.5 w-full")\\        if habit:\\            self.props("draggable")\\            self.classes("cursor-grab")\n\nclass HabitNameInput(ui.input):\\    def __init__(self, habit: DictHabit) -> None:\\        super().__init__(value=habit.name)\\        self.habit = habit\\        self.validation = self._validate\\        self.props("dense hide-bottom-space")\\        self.on("blur", self._async_task)\\    \\    async def _async_task(self):\\        self.habit.name = self.value\\        logger.info(f"Habit Name changed to {self.value}")\\    \\    def _validate(self, value: str) -> Optional[str]:\\        if not value:\\            return "Name is required"\\        if len(value) > 18:\\            return "Too long"\n\nclass HabitStarCheckbox(ui.checkbox):\\    def __init__(self, habit: DictHabit, refresh: Callable) -> None:\\        super().__init__("", value=habit.star, on_change=self._async_task)\\        self.habit = habit\\        self.bind_value(habit, "star")\\        self.props(f'checked-icon="{icons.STAR_FULL}" unchecked-icon="{icons.STAR}"')\\        self.props("flat fab-mini keep-color color=grey-8")\\        self.refresh = refresh\\    \\    async def _async_task(self, e: events.ValueChangeEventArguments):\\        self.habit.star = e.value\\        self.refresh()\\        logger.info(f"Habit Star changed to {e.value}")\n\nclass HabitDeleteButton(ui.button):\\    def __init__(self, habit: DictHabit, habit_list: DictHabitList, refresh: Callable) -> None:\\        super().__init__(on_click=self._async_task, icon=icons.DELETE)\\        self.habit = habit\\        self.habit_list = habit_list\\        self.refresh = refresh\\        self.props("flat fab-mini color=grey")\\    \\    async def _async_task(self):\\        await self.habit_list.remove(self.habit)\\        self.refresh()\\        logger.info(f"Deleted habit: {self.habit.name}")\n\nclass HabitAddButton(ui.input):\\    def __init__(self, habit_list: DictHabitList, refresh: Callable) -> None:\\        super().__init__("New item")\\        self.habit_list = habit_list\\        self.refresh = refresh\\        self.on("keydown.enter", self._async_task)\\        self.props("dense")\\        self.props("flat fab-mini color=grey")\\    \\    async def _async_task(self):\\        logger.info(f"Adding new habit: {self.value}")\\        await self.habit_list.add(self.value)\\        self.refresh()\\        self.set_value("")\\        logger.info(f"Added new habit: {self.value}")\n\nclass HabitDateInput(ui.date):\\    def __init__(self, today: datetime.date, habit: DictHabit, ticked_data: dict[datetime.date, bool]) -> None:\\        self.today = today\\        self.habit = habit\\        self.ticked_data = ticked_data\\        self.init = True\\        self.default_date = today\\        super().__init__(self.ticked_days, on_change=self._async_task)\\        self.props("multiple")\\        self.props("minimal flat")\\        self.props(f"default-year-month={self.today.strftime(MONTH_MASK)}")\\        qdate_week_first_day = (settings.FIRST_DAY_OF_WEEK + 1) % 7\\        self.props(f"first-day-of-week='{qdate_week_first_day}'")\\        self.props("today-btn")\\        self.classes("shadow-none")\\        self.bind_value_from(self, "ticked_days")\\    \\    @property\\    def ticked_days(self) -> list[str]:\\        result = [k.strftime(DAY_MASK) for k, v in self.ticked_data.items() if v]\\        result.append("today")\\        return result\\    \\    async def _async_task(self, e: events.ValueChangeEventArguments):\\        old_values = set(self.habit.ticked_days)\\        new_values = set(strptime(x, DAY_MASK).date() for x in e.value if x != "today")\\        for day in new_values - old_values:\\            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\\            self.ticked_data[day] = True\\            await self.habit.tick(day, True)\\            logger.info(f"QDate day {day} ticked: True")\\        for day in old_values - new_values:\\            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\\            self.ticked_data[day] = False\\            await self.habit.tick(day, False)\\            logger.info(f"QDate day {day} ticked: False")\n\nclass CalendarCheckBox(ui.checkbox):\\    def __init__(self, habit: DictHabit, day: datetime.date, today: datetime.date, ticked_data: dict[datetime.date, bool], is_bind_data: bool = True) -> None:\\        self.habit = habit\\        self.day = day\\        self.today = today\\        self.ticked_data = ticked_data\\        super().__init__("", value=self.ticked, on_change=self._async_task)\\        self.classes("inline-block")\\        self.props("dense")\\        unchecked_icon, checked_icon = self._icon_svg()\\        self.props(f'unchecked-icon="{unchecked_icon}"')\\        self.props(f'checked-icon="{checked_icon}"')\\        if is_bind_data:\\            self.bind_value_from(self, "ticked")\\    \\    @property\\    def ticked(self):\\        return self.ticked_data.get(self.day, False)\\    \\    def _icon_svg(self):\\        unchecked_color, checked_color = "rgb(54,54,54)", "rgb(103,150,207)"\\        return (icons.SQUARE.format(color=unchecked_color, text=self.day.day), icons.SQUARE.format(color=checked_color, text=self.day.day))\\    \\    async def _async_task(self, e: events.ValueChangeEventArguments):\\        self.ticked_data[self.day] = e.value\\        await self.habit.tick(self.day, e.value)\\        logger.info(f"Calendar Day {self.day} ticked: {e.value}")\n