import calendar\nimport datetime\nfrom dataclasses import dataclass, field\nfrom typing import Callable, Optional, List\nfrom nicegui import events, ui\nfrom nicegui.elements.button import Button\nfrom beaverhabits.configs import settings\nfrom beaverhabits.frontend import icons\nfrom beaverhabits.logging import logger\nfrom beaverhabits.storage.dict import DAY_MASK, MONTH_MASK\nfrom beaverhabits.storage.storage import Habit, HabitList\nfrom beaverhabits.utils import WEEK_DAYS\nfrom beaverhabits.frontend.components import sortable_list\nimport json\n\nstrptime = datetime.datetime.strptime\ndef link(text: str, target: str):\n    return ui.link(text, target=target).classes(\n        "dark:text-white  no-underline hover:no-underline"\n    )\ndef menu_header(title: str, target: str):\n    link = ui.link(title, target=target)\n    link.classes(\n        "text-semibold text-2xl dark:text-white no-underline hover:no-underline"\n    )\n    return link\ndef compat_menu(name: str, callback: Callable):\n    return ui.menu_item(name, callback).props("dense").classes("items-center")\ndef menu_icon_button(icon_name: str, click: Optional[Callable] = None) -> Button:\n    button_props = "flat=true unelevated=true padding=xs backgroup=none"\n    return ui.button(icon=icon_name, color=None, on_click=click).props(button_props)\nclass HabitCheckBox(ui.checkbox):\n    def __init__(\n        self,\n        habit: Habit,\n        day: datetime.date,\n        text: str = "",\n        *,\n        value: bool = False,\n    ) -> None:\n        super().__init__(text, value=value, on_change=self._async_task)\n        self.habit = habit\n        self.day = day\n        self._update_style(value)\n    def _update_style(self, value: bool):\n        self.props(\n            f'checked-icon="{icons.DONE}" unchecked-icon="{icons.CLOSE}" keep-color'\n        )\n        if not value:\n            self.props("color=grey-8")\n        else:\n            self.props("color=currentColor")\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self._update_style(e.value)\n        await self.habit.tick(self.day, e.value)\n        logger.info(f"Day {self.day} ticked: {e.value}")\nclass HabitNameInput(ui.input):\n    def __init__(self, habit: Habit) -> None:\n        super().__init__(value=habit.name, on_change=self._async_task)\n        self.habit = habit\n        self.validation = lambda value: "Too long" if len(value) > 18 else None\n        self.props("dense")\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self.habit.name = e.value\n        logger.info(f"Habit Name changed to {e.value}")\nclass HabitStarCheckbox(ui.checkbox):\n    def __init__(self, habit: Habit, refresh: Callable) -> None:\n        super().__init__("", value=habit.star, on_change=self._async_task)\n        self.habit = habit\n        self.bind_value(habit, "star")\n        self.props(f'checked-icon="{icons.STAR_FULL}" unchecked-icon="{icons.STAR}"')\n        self.props("flat fab-mini keep-color color=grey-8")\n        self.refresh = refresh\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self.habit.star = e.value\n        self.refresh()\n        logger.info(f"Habit Star changed to {e.value}")\nclass HabitDeleteButton(ui.button):\n    def __init__(self, habit: Habit, habit_list: HabitList, refresh: Callable) -> None:\n        super().__init__(on_click=self._async_task, icon=icons.DELETE)\n        self.habit = habit\n        self.habit_list = habit_list\n        self.refresh = refresh\n    async def _async_task(self):\n        await self.habit_list.remove(self.habit)\n        self.refresh()\n        logger.info(f"Deleted habit: {self.habit.name}")\nclass HabitAddButton(ui.input):\n    def __init__(self, habit_list: HabitList, refresh: Callable) -> None:\n        super().__init__("New item")\n        self.habit_list = habit_list\n        self.refresh = refresh\n        self.on("keydown.enter", self._async_task)\n        self.props("dense")\n    async def _async_task(self):\n        logger.info(f"Adding new habit: {self.value}")\n        await self.habit_list.add(self.value)\n        self.refresh()\n        self.set_value("")\n        logger.info(f"Added new habit: {self.value}")\nTODAY = "today"\nclass HabitDateInput(ui.date):\n    def __init__(\n        self, today: datetime.date, habit: Habit, ticked_data: dict[datetime.date, bool]\n    ) -> None:\n        self.today = today\n        self.habit = habit\n        self.ticked_data = ticked_data\n        self.init = True\n        self.default_date = today\n        super().__init__(self.ticked_days, on_change=self._async_task)\n        self.props("multiple")\n        self.props("minimal flat")\n        self.props(f"default-year-month={self.today.strftime(MONTH_MASK)}")\n        qdate_week_first_day = (settings.FIRST_DAY_OF_WEEK + 1) % 7\n        self.props(f"first-day-of-week='{qdate_week_first_day}'")\n        self.props("today-btn")\n        self.classes("shadow-none")\n        self.bind_value_from(self, "ticked_days")\n    @property\n    def ticked_days(self) -> list[str]:\n        result = [k.strftime(DAY_MASK) for k, v in self.ticked_data.items() if v]\n        result.append(TODAY)\n        return result\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        old_values = set(self.habit.ticked_days)\n        new_values = set(strptime(x, DAY_MASK).date() for x in e.value if x != TODAY)\n        for day in new_values - old_values:\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\n            self.ticked_data[day] = True\n            await self.habit.tick(day, True)\n            logger.info(f"QDate day {day} ticked: True")\n        for day in old_values - new_values:\n            self.props(f"default-year-month={day.strftime(MONTH_MASK)}")\n            self.ticked_data[day] = False\n            await self.habit.tick(day, False)\n            logger.info(f"QDate day {day} ticked: False")\n@dataclass\nclass CalendarHeatmap:\