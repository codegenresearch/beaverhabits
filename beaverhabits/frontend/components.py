import calendar\nimport datetime\nfrom dataclasses import dataclass, field\nfrom typing import Callable, Optional, List\n\nfrom nicegui import events, ui\nfrom nicegui.elements.button import Button\n\nfrom beaverhabits.configs import settings\nfrom beaverhabits.frontend import icons\nfrom beaverhabits.logging import logger\nfrom beaverhabits.storage.dict import DAY_MASK, MONTH_MASK\nfrom beaverhabits.storage.storage import Habit, HabitList\nfrom beaverhabits.utils import WEEK_DAYS\nfrom beaverhabits.frontend.components import sortable_list\nimport json\n\nstrptime = datetime.datetime.strptime\n\ndef link(text: str, target: str):\n    return ui.link(text, target=target).classes(\n        \\"dark:text-white no-underline hover:no-underline\\"\n    )\n\ndef menu_header(title: str, target: str):\n    link = ui.link(title, target=target)\n    link.classes(\n        \\"text-semibold text-2xl dark:text-white no-underline hover:no-underline\\"\n    )\n    return link\n\ndef compat_menu(name: str, callback: Callable):\n    return ui.menu_item(name, callback).props(\n        \\"dense\\"\n    ).classes(\n        \\"items-center\\"\n    )\n\ndef menu_icon_button(icon_name: str, click: Optional[Callable] = None) -> Button:\n    button_props = \\"flat=true unelevated=true padding=xs backgroup=none\\"\n    return ui.button(icon=icon_name, color=None, on_click=click).props(button_props)\n\nclass HabitCheckBox(ui.checkbox):\n    def __init__(\n        self,\n        habit: Habit,\n        day: datetime.date,\n        text: str = \\"\\",\n        *,\n        value: bool = False,\n    ) -> None:\n        super().__init__(text, value=value, on_change=self._async_task)\n        self.habit = habit\n        self.day = day\n        self._update_style(value)\n\n    def _update_style(self, value: bool):\n        self.props(\n            f'checked-icon="{icons.DONE}" unchecked-icon="{icons.CLOSE}" keep-color'\n        )\n        if not value:\n            self.props(\"color=grey-8\")\n        else:\n            self.props(\"color=currentColor\")\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self._update_style(e.value)\n        await self.habit.tick(self.day, e.value)\n        logger.info(f\"Day {self.day} ticked: {e.value}\")\n\nclass HabitNameInput(ui.input):\n    def __init__(self, habit: Habit) -> None:\n        super().__init__(value=habit.name, on_change=self._async_task)\n        self.habit = habit\n        self.props(\"dense\")\n\n    def _validate(self, value: str) -> Optional[str]:\n        if len(value) > 18:\n            return \\"Too long\\"\n        return None\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        if self._validate(e.value) is None:\n            self.habit.name = e.value\n            logger.info(f\"Habit Name changed to {e.value}\")\n\nclass HabitStarCheckbox(ui.checkbox):\n    def __init__(self, habit: Habit, refresh: Callable) -> None:\n        super().__init__(\"\", value=habit.star, on_change=self._async_task)\n        self.habit = habit\n        self.bind_value(habit, \\"star\\")\n        self.props(f'checked-icon="{icons.STAR_FULL}" unchecked-icon="{icons.STAR}"')\n        self.props(\"flat fab-mini keep-color color=grey-8\")\n\n        self.refresh = refresh\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        self.habit.star = e.value\n        self.refresh()\n        logger.info(f\"Habit Star changed to {e.value}\")\n\nclass HabitDeleteButton(ui.button):\n    def __init__(self, habit: Habit, habit_list: HabitList, refresh: Callable) -> None:\n        super().__init__(on_click=self._async_task, icon=icons.DELETE)\n        self.habit = habit\n        self.habit_list = habit_list\n        self.refresh = refresh\n\n    async def _async_task(self):\n        await self.habit_list.remove(self.habit)\n        self.refresh()\n        logger.info(f\"Deleted habit: {self.habit.name}\")\n\nclass HabitAddCard(ui.card):\n    def __init__(self, habit_list: HabitList, refresh: Callable) -> None:\n        super().__init__()\n        self.habit_list = habit_list\n        self.refresh = refresh\n        self.add_input()\n\n    def add_input(self):\n        input_field = ui.input(value=\"New item\")\n        input_field.on(\"keydown.enter\", self._async_task)\n        input_field.props(\"dense\")\n\n    async def _async_task(self, e: events.KeyEventArguments):\n        logger.info(f\"Adding new habit: {e.value}\")\n        await self.habit_list.add(e.value)\n        self.refresh()\n        input_field.set_value(\"\")\n        logger.info(f\"Added new habit: {e.value}\")\n\nTODAY = \\"today\\"\n\nclass HabitDateInput(ui.date):\n    def __init__(\n        self, today: datetime.date, habit: Habit, ticked_data: dict[datetime.date, bool]\n    ) -> None:\n        self.today = today\n        self.habit = habit\n        self.ticked_data = ticked_data\n        self.init = True\n        self.default_date = today\n        super().__init__(self.ticked_days, on_change=self._async_task)\n\n        self.props(\"multiple\")\n        self.props(\"minimal flat\")\n        self.props(f\"default-year-month={self.today.strftime(MONTH_MASK)}\")\n        qdate_week_first_day = (settings.FIRST_DAY_OF_WEEK + 1) % 7\n        self.props(f\"first-day-of-week=\'{qdate_week_first_day}\'")\n        self.props(\"today-btn\")\n        self.classes(\"shadow-none\")\n\n        self.bind_value_from(self, \\"ticked_days\\")\n\n    @property\n    def ticked_days(self) -> list[str]:\n        result = [k.strftime(DAY_MASK) for k, v in self.ticked_data.items() if v]\n        result.append(TODAY)\n        return result\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        old_values = set(self.habit.ticked_days)\n        new_values = set(strptime(x, DAY_MASK).date() for x in e.value if x != TODAY)\n\n        for day in new_values - old_values:\n            self.props(f\"default-year-month={day.strftime(MONTH_MASK)}\")\n            self.ticked_data[day] = True\n            await self.habit.tick(day, True)\n            logger.info(f\"QDate day {day} ticked: True\")\n\n        for day in old_values - new_values:\n            self.props(f\"default-year-month={day.strftime(MONTH_MASK)}\")\n            self.ticked_data[day] = False\n            await self.habit.tick(day, False)\n            logger.info(f\"QDate day {day} ticked: False\")\n\n@dataclass\nclass CalendarHeatmap:\n    \\"Habit records by weeks\\"\n\n    today: datetime.date\n    headers: list[str]\n    data: list[list[datetime.date]]\n    week_days: list[str]\n\n    @classmethod\n    def build(\n        cls, today: datetime.date, weeks: int, firstweekday: int = calendar.MONDAY\n    ):\n        data = cls.generate_calendar_days(today, weeks, firstweekday)\n        headers = cls.generate_calendar_headers(data[0])\n        week_day_abbr = [calendar.day_abbr[(firstweekday + i) % 7] for i in range(7)]\n\n        return cls(today, headers, data, week_day_abbr)\n\n    @staticmethod\n    def generate_calendar_headers(days: list[datetime.date]) -> list[str]:\n        if not days:\n            return []\n\n        result = []\n        month = year = None\n        for day in days:\n            cur_month, cur_year = day.month, day.year\n            if cur_month != month:\n                result.append(calendar.month_abbr[cur_month])\n                month = cur_month\n                continue\n            if cur_year != year:\n                result.append(str(cur_year))\n                year = cur_year\n                continue\n            result.append(\"\")\n\n        return result\n\n    @staticmethod\n    def generate_calendar_days(\n        today: datetime.date,\n        total_weeks: int,\n        firstweekday: int = calendar.MONDAY,  # 0 = Monday, 6 = Sunday\n    ) -> list[list[datetime.date]]:\n        # Find the last day of the week\n        lastweekday = (firstweekday - 1) % 7\n        days_delta = (lastweekday - today.weekday()) % 7\n        last_date_of_calendar = today + datetime.timedelta(days=days_delta)\n\n        return [\n            [\n                last_date_of_calendar - datetime.timedelta(days=i, weeks=j)\n                for j in reversed(range(total_weeks))\n            ]\n            for i in reversed(range(WEEK_DAYS))\n        ]\n\nclass CalendarCheckBox(ui.checkbox):\n    def __init__(\n        self,\n        habit: Habit,\n        day: datetime.date,\n        today: datetime.date,\n        ticked_data: dict[datetime.date, bool],\n        is_bind_data: bool = True,\n    ) -> None:\n        self.habit = habit\n        self.day = day\n        self.today = today\n        self.ticked_data = ticked_data\n        super().__init__(\"\", value=self.ticked, on_change=self._async_task)\n\n        self.classes(\"inline-block\")\n        self.props(\"dense\")\n        unchecked_icon, checked_icon = self._icon_svg()\n        self.props(f'unchecked-icon="{unchecked_icon}"')\n        self.props(f'checked-icon="{checked_icon}"')\n\n        if is_bind_data:\n            self.bind_value_from(self, \\"ticked\\")\n\n    @property\n    def ticked(self):\n        return self.ticked_data.get(self.day, False)\n\n    def _icon_svg(self):\n        unchecked_color, checked_color = \\"rgb(54,54,54)\\", \\"rgb(103,150,207)\\"\n        return (\n            icons.SQUARE.format(color=unchecked_color, text=self.day.day),\n            icons.SQUARE.format(color=checked_color, text=self.day.day),\n        )\n\n    async def _async_task(self, e: events.ValueChangeEventArguments):\n        # Update state data\n        self.ticked_data[self.day] = e.value\n\n        # Update persistent storage\n        await self.habit.tick(self.day, e.value)\n        logger.info(f\"Calendar Day {self.day} ticked: {e.value}\")\n\ndef habit_heat_map(\n    habit: Habit,\n    habit_calendar: CalendarHeatmap,\n    ticked_data: dict[datetime.date, bool] | None = None,\n):\n    today = habit_calendar.today\n\n    # Bind to external state data\n    is_bind_data = True\n    if ticked_data is None:\n        ticked_data = {x: True for x in habit.ticked_days}\n        is_bind_data = False\n\n    # Headers\n    with ui.row(wrap=False).classes(\"gap-0\"):\n        for header in habit_calendar.headers:\n            header_lable = ui.label(header).classes(\"text-gray-300 text-center\")\n            header_lable.style(\"width: 20px; line-height: 18px; font-size: 9px;\")\n        ui.label().style(\"width: 22px;\")\n\n    # Day matrix\n    for i, weekday_days in enumerate(habit_calendar.data):\n        with ui.row(wrap=False).classes(\"gap-0\"):\n            for day in weekday_days:\n                if day <= habit_calendar.today:\n                    CalendarCheckBox(habit, day, today, ticked_data, is_bind_data)\n                else:\n                    ui.label().style(\"width: 20px; height: 20px;\")\n\n            week_day_abbr_label = ui.label(habit_calendar.week_days[i])\n            week_day_abbr_label.classes(\"indent-1.5 text-gray-300\")\n            week_day_abbr_label.style(\"width: 22px; line-height: 20px; font-size: 9px;\")\n